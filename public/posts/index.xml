<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jack Montgomery</title>
    <link>http://localhost:1313/posts/</link>
    <description>Recent content on Jack Montgomery</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Wed, 26 Feb 2025 14:30:15 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Sequential Computation with jax.lax.scan</title>
      <link>http://localhost:1313/posts/sequential-computation-lax-scan/</link>
      <pubDate>Wed, 26 Feb 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/sequential-computation-lax-scan/</guid>
      <description>&lt;h1 id=&#34;sequential-computation-with-jaxlaxscan&#34;&gt;Sequential Computation with jax.lax.scan&lt;/h1&gt;&#xA;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;Python while having a very simple and intuitive syntax is generally not performant out of the box, esspecially with regard to control flows like loops and conditionals. &lt;a href=&#34;https://docs.jax.dev/en/latest/index.html&#34;&gt;JAX&lt;/a&gt; provides simple API&amp;rsquo;s and functional transformations to make python more performant while keeping the simple syntax. Specifically, what we will be looking into today is the &lt;a href=&#34;https://docs.jax.dev/en/latest/_autosummary/jax.lax.scan.html&#34;&gt;jax.lax.scan&lt;/a&gt;, which I will call &lt;em&gt;scan&lt;/em&gt; for short.&lt;/p&gt;&#xA;&lt;h2 id=&#34;what-is-scan-good-for&#34;&gt;What is &lt;em&gt;scan&lt;/em&gt; good for?&lt;/h2&gt;&#xA;&lt;p&gt;In the simulation of dynamical systems, for example, we are confronted with the situation of moving the coordinates through time using the rules given by some differential or difference equation. For reasons we will see late, I will call this carry. We are looking to carry inital coordinates through time. But just moving these coordinates is not really the point. We want to know store the trajectory over time, which requires us to store these coordinates, or the carry, for every timestep in the simulation. This is type of problem that &lt;em&gt;scan&lt;/em&gt; is suited for.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Solving Ordinary Differential Equations Using Neural Networks</title>
      <link>http://localhost:1313/posts/solving-odes-with-neural-networks/</link>
      <pubDate>Wed, 22 Jan 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/solving-odes-with-neural-networks/</guid>
      <description>&lt;h1 id=&#34;solving-ordinary-differential-equations-using-neural-networks&#34;&gt;Solving Ordinary Differential Equations Using Neural Networks&lt;/h1&gt;&#xA;&lt;p&gt;Neural networks typically train by backpropagating error signals from the training data. But what if we could impose additional constraints on the networkâ€™s output to guide learning? By incorporating &lt;strong&gt;physical&lt;/strong&gt; constraints into the training process, we obtain &lt;strong&gt;physics-informed neural networks (PINNs)&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;p&gt;In this post, we explore how PINNs can be used to solve ordinary differential equations (ODEs). This discussion is inspired by the work of &lt;a href=&#34;https://arxiv.org/abs/2302.12260&#34;&gt;Hubert Baty, Leo Baty&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
