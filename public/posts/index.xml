<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jack Montgomery</title>
    <link>http://localhost:1313/posts/</link>
    <description>Recent content on Jack Montgomery</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Thu, 27 Feb 2025 07:09:25 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Sequential Computation with jax.lax.scan</title>
      <link>http://localhost:1313/posts/sequential-computation-lax-scan/</link>
      <pubDate>Wed, 26 Feb 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/sequential-computation-lax-scan/</guid>
      <description>&lt;h1 id=&#34;sequential-computation-with-jaxlaxscan&#34;&gt;Sequential Computation with jax.lax.scan&lt;/h1&gt;&#xA;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;Python has a very simple and intuitive syntax that makes the developing time of a project, generally, short. The issue with python is when we start to consider the executive time for projects, esspecially intentive simulation and modelling jobs. In these scenarios julia or Matlab could be better suited to the task.&lt;/p&gt;&#xA;&lt;p&gt;One of the reasons python is slow in these simulation and physics environments is that they requiure extensive control flow. There is lots of looping and conditions which pyhon is not very good at. We will be using &lt;a href=&#34;https://docs.jax.dev/en/latest/index.html&#34;&gt;JAX&lt;/a&gt; in the post today to try an cirucmvent these control flow bottlenecks in python programs. JAX is an open source python package made by Google,  provides simple API&amp;rsquo;s and functional transformations to make python more performant while keeping the simple syntax. Specifically, what we will be looking into today is the &lt;a href=&#34;https://docs.jax.dev/en/latest/_autosummary/jax.lax.scan.html&#34;&gt;jax.lax.scan&lt;/a&gt;, which I will call &lt;em&gt;scan&lt;/em&gt; for short.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Solving Ordinary Differential Equations Using Neural Networks</title>
      <link>http://localhost:1313/posts/solving-odes-with-neural-networks/</link>
      <pubDate>Wed, 22 Jan 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/solving-odes-with-neural-networks/</guid>
      <description>&lt;h1 id=&#34;solving-ordinary-differential-equations-using-neural-networks&#34;&gt;Solving Ordinary Differential Equations Using Neural Networks&lt;/h1&gt;&#xA;&lt;p&gt;Neural networks typically train by backpropagating error signals from the training data. But what if we could impose additional constraints on the networkâ€™s output to guide learning? By incorporating &lt;strong&gt;physical&lt;/strong&gt; constraints into the training process, we obtain &lt;strong&gt;physics-informed neural networks (PINNs)&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;p&gt;In this post, we explore how PINNs can be used to solve ordinary differential equations (ODEs). This discussion is inspired by the work of &lt;a href=&#34;https://arxiv.org/abs/2302.12260&#34;&gt;Hubert Baty, Leo Baty&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
